<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>webcodecs testing</title>
</head>
<body>
<video id="sender" autoplay playsinline muted></video>
<canvas></canvas>
<br>
<video id="receiver" autoplay playsinline muted hidden></video>
<br>
<button id="start">Start</button>
<button id="getStats" disabled>getStats</button>
<button id="end">Hang-up</button>
<br>
<span id="stats"></span>

<!-- MAIN LOGIC & SENDER  -->
<script>
    const senderVideo = document.querySelector('video#sender');
    const startBtn = document.querySelector('button#start');
    const statsSpan = document.querySelector('span#stats');
    const endBtn = document.querySelector('button#end');
    const getStatsBtn = document.querySelector('button#getStats');

    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 640;
    canvas.height = 480;

    const pc = new RTCPeerConnection();
    window.pc = pc;

    const payloadSize = 90;
    const packetLossPct = .0005;

    async function sendVideo(stream) {

        stream.getTracks().forEach(track => pc.addTrack(track, stream));

        pc.onicecandidate = candidate => {
            const toReceiverEvent = new CustomEvent('candidate', {detail: candidate});
            document.dispatchEvent(toReceiverEvent);
        };

        document.addEventListener('candidate', async e => {
            console.debug(e.detail);
            if (e.detail.candidate)
                await pc.addIceCandidate(e.detail.candidate);
        });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const toReceiverEvent = new CustomEvent('offer', {detail: offer});
        document.dispatchEvent(toReceiverEvent);

        document.addEventListener('answer', async e => {
            console.debug(e.detail);
            await pc.setRemoteDescription(e.detail);
        });
    }

    startBtn.onclick = async () => {
        startBtn.disabled = true;
        console.log("starting");

        senderVideo.onplaying = () => {
            console.log("video playing stream:", senderVideo.srcObject);
        }
        const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});
        senderVideo.srcObject = stream;
        window.sendStream = stream;         // for debugging


        // Insertable Stream
        const [track] = stream.getTracks();
        const trackProcessor = new MediaStreamTrackProcessor(track);

        /*
         * WebCodecs setup
         */

        // ToDo: set the config to be the same as the input stream
        const config = {
            codec: "vp8",
            width: 640,
            height: 480,
            bitrate: 2_000_000, // 2 Mbps
            framerate: 30,
        };


        // Decoder
        const decoder = new VideoDecoder({
            output: frame => {
                ctx.drawImage(frame, 0, 0);
                frame.close();
            },
            error: e => console.error(e.message)
        });
        decoder.configure(config);

        // Encoder
        let frameCounter = 0;

        function handleEncoded(chunk, metadata) {
            if (metadata && Object.keys(metadata).length > 0) {
                console.log(metadata)
            }

            if (frameCounter % 30 === 0){
                console.log(`frame chunk # ${frameCounter}`, chunk);
            }

            /*
            if(chunk.type==='key'){
                console.log(`keyframe - chunk # ${frameCounter}`, metadata, chunk);
                // frameCounter = 1;
            }
             */

            // To see if its working
            if (frameCounter > 60){

                let junk = new Uint8Array(chunk.byteLength);
                chunk.copyTo(junk);

                for(let n = 16; n <= junk.byteLength; n+=payloadSize){
                    if(Math.random() <= packetLossPct)
                        junk.fill(0, n, n+payloadSize);
                }

                const newChunk = new EncodedVideoChunk({
                    timestamp: chunk.timestamp,
                    type: chunk.type,
                    data: junk
                });
                // console.log(newChunk);

                decoder.decode(newChunk);
            }
            else
                decoder.decode(chunk);


        }

        const {supported} = await VideoEncoder.isConfigSupported(config);
        if (supported) {
            const encoder = new VideoEncoder({
                output: handleEncoded,
                error: e => console.error(e.message)
            });
            encoder.configure(config);

            const reader = trackProcessor.readable.getReader();
            while (true) {
                const result = await reader.read();
                if (result.done) break;

                const frame = result.value;
                if (encoder.encodeQueueSize > 2) {
                    // Too many frames in flight, encoder is overwhelmed
                    // let's drop this frame.
                    console.log("encoder overwhelmed, dropping frame", frame)
                    frame.close();
                } else {
                    frameCounter++;
                    const keyFrame = frameCounter % 150 === 0; // 150
                    encoder.encode(frame, {keyFrame});
                    frame.close();
                }
            }
        } else {
            // Try another config.
            console.error("WebCodecs encoder config error");
        }


    /*
    // Insertable stream for reference
    const generatedTrack = new MediaStreamTrackGenerator({kind: 'video'});
    const moddedStream = new MediaStream([generatedTrack]);

    trackProcessor.readable
        .pipeThrough(new TransformStream({
            transform: (frame, controller) => modStream(frame, controller, encoder)
        }))
        .pipeTo(generatedTrack.writable)
        .catch(err => console.error("insertable stream error", err));
     */

    await sendVideo(stream);
    }

    endBtn.onclick = () => {
        pc.close();
        senderVideo.srcObject.getTracks().forEach(track => track.stop());
    }

</script>
<!-- RECEIVER  -->
<script>
    const receiverVideo = document.querySelector('video#receiver');

    // Look for an offer event to start the peerConnection and answer
    document.addEventListener('offer', async e => {
        console.debug(e.detail);

        const pc = new RTCPeerConnection();

        pc.ontrack = e => {
            console.debug(e);
            const stream = e.streams[0];
            receiverVideo.srcObject = stream;
            window.receiveStream = stream;
        };

        pc.onicecandidate = candidate => {
            const toReceiverEvent = new CustomEvent('candidate', {detail: candidate});
            document.dispatchEvent(toReceiverEvent);
        };

        document.addEventListener('candidate', async e => {
            console.debug(e.detail);
            await pc.addIceCandidate(e.detail.candidate);
        });


        await pc.setRemoteDescription(e.detail);

        window.receiverPc = pc;

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        const toSenderEvent = new CustomEvent('answer', {detail: answer});
        document.dispatchEvent(toSenderEvent);
    });
</script>
</body>
</html>
