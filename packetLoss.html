<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Packetloss Simulation</title>
</head>
<body>
<video id="sender" autoplay playsinline muted></video>
<video id="modded" autoplay playsinline></video>
<p>Use headphones to avoid audio feedback</p>
<button id="start">Start</button>
<button id="stop">Stop</button>
<h3>Control Encoding</h3>
<button id="send_keyframe">Send KeyFrame</button>
<form id="encoding_form" onsubmit="return false">
    <label for="video_frame_rate">Video frame rate:</label>
    <input type="number" id="video_frame_rate" value="30">

    <label for="video_bitrate">Video bitrate:</label>
    <input type="text" id="video_bitrate" value="2,000,000" pattern="([0-9]|,| |_|\.)+">

    <label for="keyframe_rate">KeyFrame Rate:</label>
    <input type="number" id="keyframe_rate" value="150">

    <label for="audio_sample_rate">Audio sample rate:</label>
    <!-- OPUS is only working with 48khz-->
    <input type="text" id="audio_sample_rate" value="48,000" pattern="([0-9]|,| |_|\.)+" disabled>

    <label for="audio_bitrate">Audio bitrate:</label>
    <input type="text" id="audio_bitrate" value="40,000" pattern="([0-9]|,| |_|\.)+" min="6000">

    <button id="apply_config">Submit</button>

</form>

<h3>Simulate Packet Loss</h3>
<p>
    video:
    <button class="video_loss" value="0">No loss</button>
    <button class="video_loss" value="0.0001">0.01%</button>
    <button class="video_loss" value="0.001">0.1%</button>
    <button class="video_loss" value="0.01">1%</button>
    <button class="video_loss" value="10">10%</button>
</p>
<p>
    audio:
    <button class="audio_loss" value="0">No loss</button>
    <button class="audio_loss" value="0.01">1%</button>
    <button class="audio_loss" value="0.05">5%</button>
    <button class="audio_loss" value="0.10">10%</button>
    <button class="audio_loss" value="0.20">20%</button>
    <button class="audio_loss" value="0.40">40%</button>
</p>
<br>
<span id="message"></span>
<script>
    const senderVideo = document.querySelector('video#sender');
    const moddedVideo = document.querySelector('video#modded');

    const startBtn = document.querySelector('button#start');
    const messageSpan = document.querySelector('span#message');
    const endBtn = document.querySelector('button#stop');

    const sendKeyFrameBtn = document.querySelector('button#send_keyframe');

    const videoFrameRateInput = document.querySelector('input#video_frame_rate');
    const videoBitrateInput = document.querySelector('input#video_bitrate');
    const keyFrameRateInput = document.querySelector('input#keyframe_rate');
    const audioSampleRateInput = document.querySelector('input#audio_sample_rate');
    const audioBitrateInput = document.querySelector('input#audio_bitrate');
    const encoderConfigBtn = document.querySelector('button#apply_config');

    const VIDEO_WIDTH = 640;
    const VIDEO_HEIGHT = 480;

    const PAYLOAD_SIZE = 200; // 90
    let videoPacketLossPct = 0, audioPacketLossPct = 0;
    let videoFrameCounter = 0, audioFrameCounter = 0;
    let manualSendKeyFrame = false;

    // Tracks for modified audio and video
    const videoGenerator = new MediaStreamTrackGenerator({kind: 'video'});
    const videoWriter = videoGenerator.writable.getWriter();

    const audioGenerator = new MediaStreamTrackGenerator({kind: 'audio'});
    const audioWriter = audioGenerator.writable.getWriter();

    const moddedStream = new MediaStream([videoGenerator, audioGenerator]);
    moddedVideo.srcObject = moddedStream;

    // allow spacers for easier entry of large numbers
    const cleanInput = (input)=>parseInt(input.replaceAll(/[,_ .]/ig, ""));


    /*
     * Packetloss function
     */

    // ToDo: audio packetloss doesn't sound realistic
    function addPacketLoss(chunk, type) {
        let chunkWithLoss = new Uint8Array(chunk.byteLength);
        chunk.copyTo(chunkWithLoss);

        const packetLoss = type === 'video' ? videoPacketLossPct : audioPacketLossPct;
        for (let n = 16; n <= chunkWithLoss.byteLength; n += PAYLOAD_SIZE) {
            if (Math.random() <= packetLoss)
                chunkWithLoss.fill(0, n, n + PAYLOAD_SIZE);
        }
        const chunkObj = {
            timestamp: chunk.timestamp,
            type: chunk.type,
            data: chunkWithLoss
        };

        if (type === 'video')
            return new EncodedVideoChunk(chunkObj);
        else if (type === 'audio')
            return new EncodedAudioChunk(chunkObj);
    }

    /*
     * WebCodecs setup
     */

    let videoConfig, audioConfig;

    function setCodecConfig(){
        videoConfig = {
            codec: "vp8",
            width: VIDEO_WIDTH,
            height: VIDEO_HEIGHT,
            bitrate: cleanInput(videoBitrateInput.value),
            framerate: cleanInput(videoFrameRateInput.value),
        };

        audioConfig = {
            numberOfChannels: 1,
            sampleRate: cleanInput(audioSampleRateInput.value),
            codec: 'opus',
            bitrate: cleanInput(audioBitrateInput.value)
        }
    }
    setCodecConfig();


    // Video decoder
    const videoDecoder = new VideoDecoder({
        output: async frame => {
            await videoWriter.write(frame);
            frame.close();
        },
        error: e => console.error(e.message)
    });
    videoDecoder.configure(videoConfig);

    // Audio decoder
    const audioDecoder = new AudioDecoder({
        output: async frame => {
            if (videoFrameCounter % 120 === 0)
                console.log("audioFrame decoder", frame);
            await audioWriter.write(frame);
            frame.close();
        },
        error: e => console.error(e.message)
    });
    audioDecoder.configure(audioConfig);


    // Encoder
    function handleEncodedVideo(chunk, metadata) {
        if (metadata.decoderConfig) {
            console.log("video metadata", metadata)
        }
        const modifiedChunk = addPacketLoss(chunk, 'video');
        videoDecoder.decode(modifiedChunk);
    }

    function handleEncodedAudio(chunk, metadata) {
        if (metadata.decoderConfig) {
            console.log("audio metadata", metadata)
        }

        /*
        if (audioFrameCounter % 120 === 0)
            console.log("audioFrame encode", chunk);
         */

        const modifiedChunk = addPacketLoss(chunk, 'audio');
        audioDecoder.decode(modifiedChunk);
    }

    const videoEncoder = new VideoEncoder({
        output: handleEncodedVideo,
        error: e => console.error(e.message)
    });

    const audioEncoder = new AudioEncoder({
        output: handleEncodedAudio,
        error: e => console.error(e.message)
    });


    VideoEncoder.isConfigSupported(videoConfig).then(supported => {
        if (supported) {
            videoEncoder.configure(videoConfig);
        } else {
            console.error("WebCodecs video encoder config error");
            messageSpan.textContent = "WebCodecs video encoder config error";
            startBtn.disabled = true;
        }
    });

    AudioEncoder.isConfigSupported(audioConfig).then(supported => {
        if (supported) {
            audioEncoder.configure(audioConfig);
        } else {
            console.error("WebCodecs audio encoder config error");
            messageSpan.textContent = "WebCodecs audio encoder config error";
            startBtn.disabled = true;
        }
    });


    async function start() {
        startBtn.disabled = true;
        console.log("starting");

        senderVideo.onplaying = () => {
            console.log("video playing stream:", senderVideo.srcObject);
        }
        const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
        senderVideo.srcObject = stream;
        window.sendStream = stream;         // for debugging

        // Insertable Stream
        const [videoTrack] = stream.getVideoTracks();
        const [audioTrack] = stream.getAudioTracks();

        const videoTrackProcessor = new MediaStreamTrackProcessor(videoTrack);
        const audioTrackProcessor = new MediaStreamTrackProcessor(audioTrack);

        const videoReader = videoTrackProcessor.readable.getReader();
        const audioReader = audioTrackProcessor.readable.getReader();

        // ToDo: move to worker
        // Note: combining these doesn't work
        async function videoLoop() {
            const videoFrameReader = await videoReader.read();
            if (videoFrameReader.done)
                return;

            const videoFrame = videoFrameReader.value;

            if (videoEncoder.encodeQueueSize > 2) {
                console.log("video encoder overwhelmed, dropping frame", videoFrame)
                videoFrame.close();
            } else {

                const keyFrame = videoFrameCounter % keyFrameRateInput.value === 0 || manualSendKeyFrame;

                if (manualSendKeyFrame) {
                    console.log(`set ${videoFrameCounter} to keyframe`);
                    manualSendKeyFrame = false;
                    manualSendKeyFrame.disabled = false;
                }

                await videoEncoder.encode(videoFrame, {keyFrame});
                videoFrameCounter++;
                videoFrame.close();
            }
            await videoLoop();
        }

        async function audioLoop() {

            const audioFrameReader = await audioReader.read();

            if (audioFrameReader.done) return;
            const audioFrame = audioFrameReader.value;

            if (audioEncoder.encodeQueueSize > 2) {
                console.log("audio encoder overwhelmed, dropping frame", videoFrame)
                audioFrame.close();
            } else {
                await audioEncoder.encode(audioFrame);
                audioFrameCounter++;
                audioFrame.close();
            }

            await audioLoop();
        }

        await Promise.all([videoLoop(), audioLoop()]);
        console.log("exiting media loops")

        videoDecoder.flush();
        videoEncoder.close();
        audioEncoder.close();
    }

    // GUI controls
    startBtn.onclick = start;

    endBtn.onclick = () => senderVideo.srcObject.getTracks().forEach(track => track.stop());

    // modify encoding parameters on the fly
    encoderConfigBtn.onclick = () => {
        setCodecConfig();
        videoEncoder.configure(videoConfig);
        videoEncoder.flush();
        videoDecoder.configure(videoConfig);
        manualSendKeyFrame = true;
        videoDecoder.flush();
        audioEncoder.configure(audioConfig);
        audioEncoder.flush();
        audioDecoder.configure(audioConfig);
        audioDecoder.flush();
    }

    document.querySelectorAll('button.video_loss').forEach(btn => btn.onclick = () => {
        videoPacketLossPct = btn.value
        document.querySelectorAll('button.video_loss').forEach(btn => btn.style.color = "black");
        btn.style.color = "red";
        console.log(`video packet loss set to ${videoPacketLossPct}`);
    });

    document.querySelectorAll('button.audio_loss').forEach(btn => btn.onclick = () => {
        audioPacketLossPct = btn.value
        document.querySelectorAll('button.audio_loss').forEach(btn => btn.style.color = "black");
        btn.style.color = "red";
        console.log(`audio packet loss set to ${audioPacketLossPct}`);

    });

    sendKeyFrameBtn.onclick = () => {
        manualSendKeyFrame.disabled = true;
        manualSendKeyFrame = true;
    }

</script>
</body>
</html>
